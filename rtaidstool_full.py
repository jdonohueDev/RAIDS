# -*- coding: utf-8 -*-
"""rtAIDSTool.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rwuDGc3mz_4TOE0D1qS2V4F5SMUp41xp
"""

#pip install scapy

from scapy.all import sniff, conf, TCP, UDP, IP
import csv
import threading
import queue
import joblib
import numpy as np
import socket
from sklearn.preprocessing import RobustScaler

import warnings
warnings.filterwarnings('ignore')

# CONFIG
conf.l3socket = conf.L3socket  # layer-3 sniffing (IP-based)
CSV_FILE = 'netlog.csv'
MODEL_FILE = r"C:/Users/JDono/Downloads/iforestTry5.joblib"
SCALER_FILE = r"C:/Users/JDono/Downloads/scalerTry5.joblib"

# Load pretrained model and scaler
try:
    isolation_forest_model = joblib.load(MODEL_FILE)
    scaler = joblib.load(SCALER_FILE)
except FileNotFoundError:
    print(f"Error: Model or scaler file not found.  Make sure '{MODEL_FILE}' and '{SCALER_FILE}' are in the correct directory.")
    exit(1)

packet_queue = queue.Queue()

# CSV INIT
def init_csv():
    """Initializes the CSV file with headers.  Handles file existence."""
    try:
        with open(CSV_FILE, mode='x', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([
                "protocol", "length",
                "src_port", "dst_port", "flags", "ttl", "payload_size", "score", "anomaly"
            ])
    except FileExistsError:
        print(f"CSV file '{CSV_FILE}' already exists. Appending to it.")
    except Exception as e:
        print(f"Error initializing CSV file: {e}")
        exit(1)

# CSV WRITER THREAD
def write_to_csv():
    """Thread function to write packet data to the CSV file."""
    while True:
        packet_data = packet_queue.get()
        if packet_data is None:
            break
        try:
            with open(CSV_FILE, mode='a', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(packet_data)
        except Exception as e:
            print(f"Error writing packet to CSV: {e}")
        finally:
            packet_queue.task_done()

# FEATURE EXTRACTION
def extract_features(packet):
    """Extracts and preprocesses features from a packet.  Handles missing layers."""
    try:
        if IP in packet:
            proto = packet.proto
            length = len(packet)
            ttl = packet[IP].ttl

            src_port = 0
            dst_port = 0
            flags = 'NaN'
            payload_size = 0

            if TCP in packet:
                src_port = packet[TCP].sport
                dst_port = packet[TCP].dport
                flags = packet[TCP].flags
                if packet.haslayer('Raw'):  # Check for Raw layer before accessing payload
                    payload_size = len(packet['Raw'].load)
                else:
                    payload_size = 0

            elif UDP in packet:
                src_port = packet[UDP].sport
                dst_port = packet[UDP].dport
                if packet.haslayer('Raw'): # Check for Raw layer before accessing payload
                    payload_size = len(packet['Raw'].load)
                else:
                    payload_size = 0

            # Protocol to integer mapping
            protocol_mapping = {"ICMP": 1, "TCP": 6, "UDP": 17}
            proto_int = protocol_mapping.get(proto, 0)

            # Flags to numeric mapping
            flags_map = {'NaN': 0, 'A': 1, 'PA': 2, 'FA': 3, 'S': 4, 'SA': 5,
                         'RA': 6, 'R': 7, 'FPA': 8}
            flags_numeric = flags_map.get(flags, 0)

            # create feature vector
            raw_vector = np.array([
                proto_int, length,
                src_port, dst_port, flags_numeric, ttl, payload_size,
            ], dtype=float).reshape(1, -1)

            # normalize numerical features
            scaled_vector = scaler.transform(raw_vector)
            return scaled_vector

        else:
            return None # Return None for non-IP packets

    except Exception as e:
        print(f"Feature extraction error: {e}")
        return None

# PACKET SNIFFER CALLBACK
def packet_callback(packet):
    """Callback function for the packet sniffer.  Handles packet processing and anomaly detection."""
    try:
        features = extract_features(packet)
        if features is not None:
            score = isolation_forest_model.decision_function(features)[0]
            if isolation_forest_model.predict(features)[0] == -1 :
                anomaly = 1
            else:
                anomaly = 0

            if anomaly == 1:
                print("\nðŸ”´ Anomaly detected!")
            else:
                print("\nðŸŸ¢ No anomaly detected.")

            print(f"Packet: Score = {score:.3f}, Anomaly = {anomaly}")
            print(features[0])

            # Prepare data for CSV logging
            if IP in packet: # Make sure it is IP packet
                print(f"IP: {packet[IP]}")
                proto = packet.proto
                length = len(packet)
                ttl = packet[IP].ttl
                src_port = 0
                dst_port = 0
                flags = 'NaN'
                payload_size = 0
                if TCP in packet:
                  src_port = packet[TCP].sport
                  dst_port = packet[TCP].dport
                  flags = packet[TCP].flags
                  if packet.haslayer('Raw'):
                    payload_size = len(packet['Raw'].load)
                elif UDP in packet:
                  src_port = packet[UDP].sport
                  dst_port = packet[UDP].dport
                  if packet.haslayer('Raw'):
                    payload_size = len(packet['Raw'].load)

                packet_data = [
                    proto, length,
                    src_port, dst_port, flags, ttl, payload_size, score, anomaly
                ]
                packet_queue.put(packet_data)

    except Exception as e:
        print(f"Error processing packet: {e}")

# SNIFFER CONTROL
def start_sniffing():
    """Starts the packet sniffing process."""
    print("Sniffing started... Press Ctrl+C to stop.")
    try:
        sniff(prn=packet_callback, store=False)
    except Exception as e:
        print(f"Error starting sniffing: {e}")

# MAIN EXPERIMENT
if __name__ == "__main__":
    init_csv()

    # spin CSV writer thread
    write_thread = threading.Thread(target=write_to_csv, daemon=True)
    write_thread.start()

    try:
        start_sniffing()
    except KeyboardInterrupt:
        print("Stopping sniffing...")
        packet_queue.put(None)
        write_thread.join()
        print("IDS stopped.")
    except Exception as e:
        print(f"An error occurred: {e}")